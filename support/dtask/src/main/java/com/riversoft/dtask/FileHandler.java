package com.riversoft.dtask;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.channels.FileChannel;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * FileHandler is a helper class for writing log files for Ant utilities,
 * like BuildLogger and InputHandler. FileHandler implements the Singleton
 * design pattern and can be manipulated by any object without them holding
 * an instance of this class.
 * 
 * The simplest way to write to the log file is to type:
 * FileHandler.getInstance().write("Log message goes here");
 * 
 * However, it is recommended that the path to the log file is specified
 * the first time any method in this class is invoked. E.g
 * FileHandler.getInstance("/opt/drutt", "install.log").write("First log message!");
 * or simply
 * FileHandler.getInstance("/opt/drutt", "install.log");
 * 
 */
public class FileHandler {

    private FileWriter fw = null;
    private File logfile = null;
    private String workingDir = null;

    private static FileHandler instance = null;

    /**
     * Creates a new file and initilizes a FileWriter on that file
     * 
     * @param filepath The path to the file, exluding the file name
     * @param filename The name of the file, exluding the path
     */
    private FileHandler(String filepath, String filename) {
        try {
            File dir = new File(filepath);
            dir.mkdirs();
            workingDir = filepath;
            logfile = new File(filepath + "/" + filename);

            fw = new FileWriter(logfile, true);
        } catch (IOException e) {
            System.err.println("Error initilizing file writer: " + e);
            e.printStackTrace();
        }
    }

    /**
     * Return an instance of FileHandler. FileHandler implements the
     * Singleton design pattern, allowing the same instance can be statically
     * accessed from multiple objects without them having a prior reference
     * to it.
     * 
     * @return The current instance of FileHandler
     */
    public static FileHandler getInstance() {
        if (instance == null) {
            instance = new FileHandler("log", "riversoft.log");
        }

        return instance;
    }

    /**
     * Return an instance of FileHandler. FileHandler implements the
     * Singleton design pattern, allowing the same instance can be statically
     * accessed from multiple objects without them having a prior reference
     * to it.
     * This method allows the calling object to specify a path and a name to
     * a file it wishes to manipulate. Note that this does only work the first
     * time getInstance(String, String) is invoked, and any further calls to
     * this method will not change or set which file to manipulate. To do this,
     * use setFile(String, String).
     * 
     * @return The current instance of FileHandler
     */
    public static FileHandler getInstance(String filepath, String filename) {
        if (instance == null) {
            instance = new FileHandler(filepath, filename);
        }

        return instance;
    }

    /**
     * Sets which file to manipulate. If the file does not exist, it will be
     * created. If a file does exist, it will be overwritten.
     * 
     * @param filepath The path to the file, exluding the file name
     * @param filename The name of the file, exluding the path
     */
    public void setFile(String filepath, String filename) {
        try {
            fw.flush();
            fw.close();
        } catch (IOException e) {
            System.err.println(e.getMessage());
            e.printStackTrace();
        }
        instance = new FileHandler(filepath, filename);
    }

    /**
     * Moves the file which is currently being manipulated to the designated
     * path.
     * 
     * @param filepath The whole directory path, excluding the filename. The
     *            filename is instead generated by this method.
     */
    public void moveFile(String filepath) {
        File dir = new File(filepath);
        dir.mkdirs();

        Date d = new Date();
        SimpleDateFormat dstamp = new SimpleDateFormat("yyyyMMdd");
        SimpleDateFormat tstamp = new SimpleDateFormat("HHmm");

        String ext = String.format("%1$s-%2$s", dstamp.format(d), tstamp.format(d));
        File newFile = new File(filepath + "/riversoft-" + ext + ".log");

        try {
            fw.flush();
            fw.close();

            // Copy file
            FileChannel from = new FileInputStream(logfile).getChannel();
            FileChannel to = new FileOutputStream(newFile).getChannel();
            to.transferFrom(from, 0, from.size());
            from.close();
            to.close();

            // Remove any trace of the old file
            logfile.delete();
            File tmpDir = new File(workingDir);
            tmpDir.delete();

            // Reset everything on the new file.
            workingDir = filepath;
            logfile = newFile;
            fw = new FileWriter(logfile, true);
        } catch (IOException e) {
            System.err.println("An error occured while moving the log file");
            System.err.println(e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Writes a String to the currently opened file. Does not append '\n'.
     * 
     * @param message The message to write.
     */
    public void write(String message) {
        try {
            fw.write(message);
            fw.flush();
        } catch (IOException e) {
            System.err.println("Could not write to file: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
